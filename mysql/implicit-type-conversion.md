# 암시적 형 변환이란?
* 서로 다른 타입을 비교하거나 연산할 때, MySQL이 데이터 타입을 자동으로 변환하는 것
* 암시적 형 변환이 필요한 이유
    * SQL은 서로 다른 타입 간 비교를 문법적으로 허용함
    * 서로 다른 타입 간 연산을 가능하게 하기 위해
    * 사용자 편의성을 위해
<br>

# 기본 규칙
1. **연산에 따라 목표 타입이 결정된다**
    * 어떤 연산이 수행되는지에 따라 변환 방향이 결정됨
        * 숫자 연산 → 숫자 타입
        * 문자열 연산 → 문자열 타입
        * 날짜/시간 연산 → 날짜/시간 타입
        * boolean 컨텍스트 → 숫자 기반으로 평가
            * 0 = false
            * null = unknown
            * 그 외 = true
2. **타입 우선순위에 따라 변환한다**
    * `숫자 > 날짜/시간 > 문자열`
    * 우선순위가 낮은 타입이 높은 타입으로 변환됨
3. **`null`은 어떤 타입으로도 변환되지 않는다**
    * null 은 값이 아니라 `알 수 없음`을 의미함
    * 숫자, 문자열, 날짜/시간 중 어느 타입으로도 변환되지 않음
    * null이 포함된 산술 연산이나 함수 연산의 결과는 대부분 `null`
<br>

# 비교 연산에서의 암시적 형 변환
* 비교 연산(`=`, `!=`, `<`, `>`, `<=`, `>=`, `<=>`)에서는 서로 비교 가능한 단일 타입으로 변환한 후 비교 수행
    * 정수 vs 실수
        * 정수를 `실수`로 변환
    * 숫자 vs 문자열
        * 문자열을 `숫자`로 변환
        * 문자열 앞부분부터 숫자로 해석 가능한 부분만 변환
        * 숫자로 변환할 수 없다면 warning이 발생할 수 있음
    * 날짜/시간 vs 문자열
        * 문자열을 `날짜/시간`으로 변환
        * 날짜 포맷이 맞지 않으면 null 또는 warning이 발생할 수 있음
    * 날짜/시간 vs 숫자
        * 날짜/시간 값을 `숫자` 표현으로 변환
    * null 비교
        * NULL-safe 비교 연산자(`<=>`)는 null 비교 가능
            * `null <=> null` → true
            * `null <=> 값` → false
        * 그 외 null이 포함된 비교 연산의 결과는 항상 `unknown`
            * unknown은 where 조건에서 true로 평가되지 않음
        * `is null` / `is not null` 을 사용해서 비교해야 함
<br>

# 기타 컨텍스트 별 암시적 형 변환
* 함수 인자 타입 불일치
    * 함수는 특정 타입의 인자를 기대함
    * 전달된 인자의 타입이 다른 경우 `명시된 인자의 타입`으로 암시적 형 변환 발생
    * 변환 실패 시 null 또는 warning이 발생할 수 있음
* INSERT
    * 입력 값은 `명시된 대상 컬럼의 타입`으로 변환됨
    * `strict mode` 설정에 따라 error, warning, 자동 보정 여부가 달라짐
* ORDER BY / GROUP BY
    * 정렬/그룹화 대상이 컬럼이 아닌 표현식 또는 결과 집합일 경우 암시적 형 변환 발생 
    * 정렬/그룹화 전에 공통 데이터 타입이 결정됨
        * `타입 우선순위`에 따라 결정
    * 결정된 타입에 따라 정렬/그룹화 기준이 달라짐
* UNION / UNION ALL 컬럼 타입 통합
    * 각 select 결과 컬럼의 타입을 기준으로 `타입 우선순위`에 따라 공통 결과 타입이 결정됨